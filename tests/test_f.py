import unittest
import os
import unittest
import numpy as np
from common import F
import torch
import hypothesis.strategies as st
from hypothesis import given, settings

class TestFHexToAz(unittest.TestCase):
    def test_no_args(self):
        self.assertEqual(F.hex_to_az(""), "")

    def test_with_nums_and_upper_case(self):
        self.assertEqual(F.hex_to_az("A0", with_nums=True, with_upper=True), "z")

    def test_with_syms(self):
        self.assertEqual(F.hex_to_az("30", with_syms=True), "t")

    def test_with_nums_only(self):
        self.assertEqual(F.hex_to_az("1234", with_nums=True), "hf")

    def test_all_syms1(self):
        s = ''.join(f"{i:02x}" for i in range(256))
        self.assertEqual(F.hex_to_az(s, with_nums = True, with_upper = True, with_syms = True),
        ".0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_.0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_.0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_.0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_")

    def test_all_syms2(self):
        s = ''.join(f"{i:02x}" for i in range(256))
        self.assertEqual(F.hex_to_az(s, with_nums = False, with_upper = False, with_syms = False),
        "zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstu")

class TestF(unittest.TestCase):
    @given(st.text())
    @settings(max_examples=10)
    def test_caller_str(self, text):
        result = F.caller_str()
        self.assertTrue(isinstance(result, str))

    @given(st.text(), st.integers())
    def test_uhash(self, s: str, i: int):
        self.assertIsInstance(F.uhash(s), int)
        self.assertIsInstance(F.uhash(i), int)

    @given(st.text(), st.integers())
    def test_random_id(self, s: str, i: int):
        id = F.random_id(10)
        self.assertIsInstance(id, str)
        self.assertEqual(len(id), 10)

    @given(st.lists(st.text()))
    def test_l_eq(self, ls1: list[str]):
        self.assertTrue(F.l_eq(ls1, ls1))

    @given(st.dictionaries(st.text(), st.integers()))
    def test_d_eq(self, d1: dict[str, int]):
        self.assertTrue(F.d_eq(d1, d1))

    # и т. д.
    def test_d_eq(self):
        a = {"a":1,"b":2,"c":1,"d":2}
        b = {"a":1,"b":2,"c":1,"d":2}
        c = {"a":1,"b":2,"c":3,"d":2}
        d = {"a":1,"b":2,"c":3,"d":2, "e":{"a":1,"b":2,"c":1,"d":2}}
        d2 = {"a":1,"b":2,"c":3,"d":2, "e":{"a":1,"b":2,"c":1,"d":2}}
        e = {"a":1,"b":2,"c":3,"d":2, "e":{"a":1,"b":2,"c":2,"d":2}}
        self.assertTrue(F.d_eq(a, a))
        self.assertTrue(F.d_eq(d, d))
        self.assertTrue(F.d_eq(e, e))
        self.assertTrue(F.d_eq(None, None, maybe_none=True))
        self.assertFalse(F.d_eq(a, None, maybe_none=True))
        self.assertTrue(F.d_eq(None, None, maybe_none=True))
        self.assertFalse(F.d_eq(None, a, maybe_none=True))
        self.assertTrue(F.d_eq(a, b))
        self.assertTrue(F.d_eq(b, a))
        self.assertFalse(F.d_eq(a, c))
        self.assertFalse(F.d_eq(b, c))
        self.assertFalse(F.d_eq(c, a))
        self.assertFalse(F.d_eq(c, b))
        self.assertFalse(F.d_eq(c, d))
        self.assertFalse(F.d_eq(d, c))
        self.assertTrue(F.d_eq(d, d2))
        self.assertFalse(F.d_eq(d, e))
        self.assertFalse(F.d_eq(d2, e))

    # Test the length of a random ID generated by the random_id() function
    def test_random_id_length(self):
        # Check that the length of the generated ID is equal to the specified length
        length = 10
        token = F.random_id(length)
        self.assertEqual(len(token), length)

    # Test that an empty dictionary is correctly sorted by the dsort() function
    def test_dsort_empty_dict(self):
        # Create an empty dictionary
        dict = {}
        # Sort the dictionary and check that its length is zero
        sorted_dict = F.dsort(dict)
        self.assertEqual(len(sorted_dict), 0)

    # Test that two lists are considered equal by the l_eq() function
    def test_l_eq_equal_list(self):
        # Create two lists with the same elements
        list1 = [1, 2, 3]
        list2 = [1, 2, 3]
        # Check that the lists are equal
        self.assertTrue(F.l_eq(list1, list2))

    # Test that two empty dictionaries are considered equal by the d_eq() function
    def test_d_eq_empty_dicts(self):
        # Create two empty dictionaries
        dict1 = {}
        dict2 = {}
        # Check that the dictionaries are equal
        self.assertTrue(F.d_eq(dict1, dict2))

    # Test that two non-empty dictionaries are not considered equal by the d_eq() function
    def test_d_eq_dict_values(self):
        # Create two non-empty dictionaries with different values
        dict1 = {"a": 1, "b": 2}
        dict2 = {"a": 3, "b": 4}
        # Check that the dictionaries are not equal
        self.assertFalse(F.d_eq(dict1, dict2))

    # Test that an empty dictionary is correctly sorted by value using the dsort_val() function
    def test_dsort_val_empty_dict(self):
        # Create an empty dictionary
        dict = {}
        # Sort the dictionary and check that its length is zero
        sorted_dict = F.dsort_val(dict)
        self.assertEqual(len(sorted_dict), 0)

    # Test that a new token is correctly generated by the generateToken() function
    def test_generateToken(self):
        # Generate two tokens
        token1 = F.generateToken()
        token2 = F.generateToken()
        # Check that the tokens are not equal
        self.assertNotEqual(token1, token2)

    # Test that a node name is correctly generated by the getNodeName() function
    def test_getNodeName(self):
        # Generate a new node name
        name_hash = F.getNodeName()
        # Check that the result is a string
        self.assertIsInstance(name_hash, str)

    # Test that an ID is correctly generated by the generateOID() function
    def test_generateOID(self):
        # Generate two IDs
        id1 = F.generateOID()
        id2 = F.generateOID()
        # Check that the IDs are not equal
        self.assertNotEqual(id1, id2)

    def test_tensor_to_float(self):
        t = F.tensor_to_float(torch.tensor(0.5))
        self.assertAlmostEqual(t, 0.5)

    def test_sizeof_str(self):
        self.assertEqual(F.sizeof_str(10), '32 Bytes (32b)')

    def test_approximate(self):
        lower_bound = 0.5
        upper_bound = 1.5
        n = 10 # middle count
        result = F.approximate(lower_bound, upper_bound, n)
        self.assertEqual(len(result), n + 2)
        
    def test_i_approximate(self):
        lower_bound = 0.5
        upper_bound = 1.5
        n = 10 # middle count
        result = F.i_approximate(lower_bound, upper_bound, n)
        self.assertEqual(len(result), n + 2)

    def test_isHexString_empty_string(self):
        self.assertFalse(F.isHexString(""))

    def test_isHexString_single_character(self):
        self.assertTrue(F.isHexString("0"))
        self.assertTrue(F.isHexString("1"))
        self.assertTrue(F.isHexString("a"))
        self.assertTrue(F.isHexString("A"))

    def test_isHexString_multiple_characters(self):
        self.assertTrue(F.isHexString("abcdef"))
        self.assertTrue(F.isHexString("ABCDEF"))

    def test_isHexString_empty_string(self):
        self.assertFalse(F.isHexString(""))
        self.assertFalse(F.isHexString(" "))

    def test_isHexString_single_character(self):
        self.assertTrue(F.isHexString("0"))
        self.assertTrue(F.isHexString("1"))
        self.assertTrue(F.isHexString("a"))
        self.assertTrue(F.isHexString("A"))

    def test_isHexString_multiple_characters(self):
        self.assertTrue(F.isHexString("abcdef"))
        self.assertTrue(F.isHexString("ABCDEF"))

    def test_isHexString_non_hex_string(self):
        self.assertFalse(F.isHexString("hello"))
        self.assertFalse(F.isHexString("world"))
        self.assertFalse(F.isHexString("python"))

    def test_isHexString_numbers_only(self):
        self.assertTrue(F.isHexString("1234567890"))

    def test_isHexString_alphabets_only(self):
        self.assertFalse(F.isHexString("abcdefghijklmnopqrstuvwxyz"))
        self.assertFalse(F.isHexString("ABCDEFGHIJKLMNOPQRSTUVWXYZ"))

    def test_isHexString_hex_string_with_spaces(self):
        self.assertTrue(F.isHexString("abcdef "))
        self.assertTrue(F.isHexString(" abcdef "))
        self.assertTrue(F.isHexString("    abcdef            "))
        self.assertFalse(F.isHexString("abcde f"))

    def test_uhash_empty_and_none(self):
        self.assertIsInstance(F.uhash(""), int)
        self.assertIsInstance(F.uhash(None), int)

    def test_random_id_zero_and_negative(self):
        with self.assertRaises(ValueError):
            F.random_id(0)
        with self.assertRaises(ValueError):
            F.random_id(-1)

    def test_hex_to_az_invalid(self):
        self.assertEqual(F.hex_to_az("nothex"), "")
        self.assertEqual(F.hex_to_az("!@#$%^"), "")

    def test_tensor_to_float_invalid(self):
        with self.assertRaises(Exception):
            F.tensor_to_float([1, 2, 3])  # not a torch.Tensor

    def test_sizeof_str_various(self):
        self.assertIsInstance(F.sizeof_str("test"), str)
        self.assertIsInstance(F.sizeof_str(None), str)
        self.assertIsInstance(F.sizeof_str(123), str)

    def test_approximate_zero(self):
        with self.assertRaises(ValueError):
            F.approximate(1.0, 1.0, 0)

    def test_i_approximate_negative(self):
        with self.assertRaises(ValueError):
            F.i_approximate(1.0, 2.0, -1)

    def test_dsort_non_numeric(self):
        d = {"a": "x", "b": "y"}
        sorted_d = F.dsort(d)
        self.assertIsInstance(sorted_d, dict)

    def test_generateToken_uniqueness(self):
        tokens = {F.generateToken() for _ in range(100)}
        self.assertEqual(len(tokens), 100)

    def test_generateOID_uniqueness(self):
        oids = {F.generateOID() for _ in range(100)}
        self.assertEqual(len(oids), 100)
